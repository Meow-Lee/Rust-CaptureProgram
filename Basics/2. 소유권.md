# 소유권
## 2-1. 소유권
- Rust 프로그램의 메모리 관리법을 지배하는 규칙 모음
- 모든 프로그램은 작동하는 동안 컴퓨터의 메모리 사용 방법을 관리해야 함
- 소유권이라는 시스템을 만들고, 컴파일러가 컴파일 중에 검사할 여러 규칙을 정해 메모리를 관리하는 방식을 택함
### 소유권 규칙
1. 각각의 값은 소유자가 정해져 있음
2. 한 값의 소유자는 동시에 여럿 존재할 수 없음
3. 소유자가 스코프 밖으로 벗어날 때, 값은 버려짐

```rust
{
  let s = "hello"; // 이 지점부터 s가 유효함
  // 추가 작업
}  // 스코프 종료, s는 더 이상 유효하지 않음
```

### String 타입
```rust
// String::from() 호출 시 필요한 만큼 메모리를 요청하도록 구현
let s = String::from("hello"); // from 함수와 문자열 리터럴을 이용해 생성 가능

s.push_str(", world!"); // push_str() 문자열에 리터럴을 추가

println!("{}", s);
```
- 문자열 리터럴과 String은 각 타입의 메모리 사용 방식이 다름
- **문자열 리터럴** => 컴파일 타임에 내용을 알 수 있으므로, 텍스트가 최종 실행 파일에 하드코딩 됨
- **String** => 힙에 메모리를 할당ㅇ하는 방식을 사용하므로, 텍스트 내용 및 크기를 변경할 수 있음
- 하지만 실행 중 메모리 할당자로부터 메모리를 요청해야 함
- String 사용을 마쳤을 때 메모리를 해제할 방법이 필요함
- Rust는 변수가 스코프 밖으로 벗어나면 **drop**이라는 특별한 함수를 호출
- 이는 메모리 해제 코드가 호출되는데, 닫힌 중괄호가 나타나는 지점에서 자동 호출됨 (ex. C++에서는 RAII 패턴)
```rust
let s1 = String::from("Hello");
let s2 = s1;

println!("{}", s1); // 중복 해제 에러 발생

// s1의 데이터가 스택에 있고(힙에 있는 데이터를 가리키는 포인터, 길이, 용량) s2=s1을 하게되면 s2의 포인터도 같은 데이터를 가리키기 때문에
// 스코프가 끝나는 시점에서 자동으로 drop 함수를 호출하게 되면 힙에 있는 동일 데이터를 두 번 해제하게 되기 때문에 위와 같은 에러가 발생
// 따라서, s2 = s1을 하게 되면, s1은 더이상 유효하지 않다고 판단하므로 s2만 println!을 할 수 있음
// 얕은 복사가 아닌가 할 수 있지만, rust에서는 기존 변수를 무효화하므로 이동(move)했다고 하고, s1이 s2로 이동되었다라고 표현
```

### 클론
- String의 힙 데이터까지 깊이 복사하고 싶을 땐 **clone** 공용 메서드 사용 가능

### 복사
- 스택에만 저장되는 데이터
- 정수형 등 컴파일 타임에 크기가 고정되는 타입은 모두 스택에 저장되므로, 복사본을 빠르게 만들 수 있고 무효화할 필요도 없음
- 즉, 깊은 복사와 얕은 복사 간 차이가 없음
```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

## 2-2. 참조와 대여
- **참조자** => 해당 주소에 저장된 데이터에 접근할 수 있도록 해주는 주소값에 해당하는 포인터와 같은 것
```rust
fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

- &기호가 참조자를 나타내고, 어떤 값의 소유권을 가져오지 않고 해당 값을 참조할 수 있도록 함
- 이처럼 참조자를 만드는 행위를 **대여**(borrow)라고 함

```rust
fn main() {
    let mut s = String::from("hello");
    
    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
- 위와 같이 **가변 참조자**를 사용하면 push_str()를 사용할 수 있음
- 단, 가변 참조자를 생성했으면, 참조자를 더 생성할 수 없음
- 반대로도, 참조자가 있으면 가변 참조자를 생성할 수 없음
- 참조자는 해당 참조자가 마지막으로 사용된 부분까지 유효함
```rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &s;
    let r2 = &s;
    println!("{}, {}", r1, r2);

    let r3 = &mut s;
    r3.push_str(", world!");

    println!("{}", r3);
}
```

### 댕글링 참조
- **댕글링 포인터** => 어떤 메모리를 가리키는 포인터가 남아있는 상황에서 일부 메모리를 해제해버림으로써, 다른 개체가 할당받았을지도 모르는 메모리를 참조하게된 포인터
- rust에서는 어떤 데이터의 참조자를 만들면, 해당 참조자가 스코프를 벗어나기 전에 데이터가 먼저 벗어나는지 컴파일러에서 확인하므로 댕글링 참조가 생성되지 않도록 보장
```rust
fn main() {
    let reference_to_nothing = dangle(); // 댕글링 참조가 일어나면서 에러 발생
}

fn dangle() -> &String {
    let s = String::from("Hello");

    &s // -> s를 직접 반환해야 소유권이 이동하면서 메모리도 할당 해제 되지 않음
} // 이 시점에 s는 스코프 밖으로 벗어나면서 버려지고, 메모리는 해제되므로
```

## 2.3 슬라이스
- 컬렉션의 연속된 일련의 요소를 참조하도록 함
- 슬라이스는 참조자의 일종으로서 소유권을 갖지 않음
